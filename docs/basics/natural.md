# Natural Numbers

## Basics

Natural numbers are defined in Coq as an inductive type.
```ocaml
    Inductive nat: Set :=
    | O: nat
    | S: nat -> nat.
```
The constructor `O` (note: it is the capital letter `O` an not the number `0`)
represents the number zero and the constructor `S` represents the successor
function.

The inductively defined natural numbers are a completely inefficient when used
as actual data types in a program. Then number `5` is represented as `S (S (S
(S (S 0))))`. Imagine how the number `1000000000` (one billion) is
represented. However these natural numbers are a powerful mathematical
concept. Natural numbers can be used in proofs. Since all proofs are erased
during extraction no runtime overhead is generated by using natural numbers
only in proofs.

The Coq parser has a special hack to write natural numbers conveniently. You
can write `2` and the Coq parser expands it to `S (S O)` or you can write `0`
and the Coq parser expands it to `O`.

In the following we prove some theorems about natural numbers. All the
theorems are included in the `Core.v` source file within a module `Nat` and
can be used by `Require Import Core` in any other Coq source file.

First we define a predicate describing if a number is the successor of another
number.

    Definition is_Successor (n:nat): Prop :=
      match n with
      | 0 => False
      | S _ => True
      end.

We prove that any number of the form `S n` cannot be equal to `0`.

    Theorem successor_not_zero:
      forall n:nat, S n <> 0.
    Proof
      fun n (p: S n = 0) =>
        (* Use the propositon 'is_Successor' which is trivially provable for 'S n'
         and rewrite 'S n' into '0' by using 'p' and generate a proof for
         'False'. With that we get 'S n = 0 -> False' which is the required
         result. *)
        Equal.rewrite p is_Successor I.

The predicate `is_Successor` is decidable. We can provide a decision procedure
for the predicate (or better said: for the negation of the predicate).

    Definition is_zero (n:nat): {n = 0} + {n <> 0} :=
      match n with
      | 0   => left eq_refl
      | S n => right (@successor_not_zero n)
      end.

> Note: We could have used `bool` as the return type of `is_zero` and returned
  `true` in the first case and `false` in the second case. But writing
  `is_zero` as a decision procedure is better because a pattern match on the
  result of `is_zero n` gives us a case with a proof of `n = 0` and a case
  with a proof of `n <> 0`. The proofs can be used as arguments to other
  function call in the corresponding cases.

The successor function is injective.

    Theorem successor_injective:
      forall n m:nat, S n = S m -> n = m.
    Proof
      fun n m p =>
        let f x := match x with
                     O => n
                   | S y => y end in
        Equal.inject p f.

Any number `n` is different from its successor. The proof of this property
needs an induction proof i.e. a recursive function generating the proof.

    Theorem successor_different (n:nat): n <> S n.
    Proof
      let f :=
          fix f n: S n <> n:=
            match n with
            | O =>
              fun p:S 0 = 0 => (@successor_not_zero 0) p
            | S k =>
              fun p: S (S k) = S k =>
                f k (successor_injective p: S k = k)
            end
      in
      Equal.flip_not_equal (f n).


Equality of natural numbers is decidable. We define the obvious decision
procedure.

    Definition is_equal: forall a b:nat, {a = b} + {a <> b} :=
      fix f a b: {a = b} + {a <> b} :=
        match a, b with
        | O, O => left eq_refl
        | S n, O => right (@successor_not_zero n)
        | O, S n => right (Equal.flip_not_equal (@successor_not_zero n))
        | S n, S k =>
          match f n k: {n = k} + {n <> k} with
          | left p =>
            left (Equal.inject p S)
          | right p => (* p: n = k -> False *)
            right (fun q:S n = S k =>
                     p (successor_injective q:n = k))
          end
        end.

## Predecessor as a Partial Function

The standard library of Coq defines the following predecessor function.

    Definition pred (n:nat): nat :=
      match n with
      | 0 => 0
      | S m => m
      end.

Since `0` has no predecessor the function cannot compute it. The function
chooses to return `0` as the predecessor of `0` in order to return something
meaningful.

But the predecessor function is partial. It is not defined for the number
`0`. Coq allows us to write partial function by using an additional argument
which proves that the argument is within the domain of the function. The
partial function should have the following signature.

    predecessor (n:nat) (p:is_Successor): nat := ...

However we can do better than that. The function should not return a natural,
it should return a number which is the predecessor of `n`. In order to specify
this exactly the Coq standard library defines the following inductive type.

    Inductive sig (A : Type) (P : A -> Prop) : Type :=
        exist : forall x : A, P x -> sig A P

The constructor `exist` makes from an object `x` of type `A` and a proof of `P
x` an object of type `@sig A P` (note: The argument `A` is implicit). I.e. an
object of type `@sig A P` contains an object of type `A` and a proof that it
satisfies the predicate `P`. By pattern matching on an object of type `@sig A
P` we can retrieve the object and the proof.

Since objects bundled with a proof of a property are used frequently, Coq
provides a notation.
```ocaml
    {x:A | P x}     (* is a notation for `@sig A P` *)
```

We can use a sig-type to specify the result of the predecessor function. The
predecessor function should have the signature

    predecessor (n:nat) (p:is_Successor): {i:nat | S i = n} := ...

The complete function looks like

    Definition predecessor (n:nat) (p:is_Successor n): {x:nat|S x = n} :=
      (match n with
      | 0 => fun p:is_Successor 0 => match p with end
      | S m => fun _ => exist _ m eq_refl
      end) p.


For the first case we need the proof `p` to derive a contradiction. For the
second case the proof is not needed. For the second case we need a number `x`
and a proof of `S x = S m`. Clearly the number `x` is the number `m` an the
proof is a trivial proof of reflexivity. The type inferer of Coq infers the
predicate `fun x => S x = S m` automatically. Therefore we can use the
wildcard `_` as the first argument of the constructor `exist`.


## Order Structure

Natural numbers have an order structure. If we have one number `n`, then `n <=
n` is valid. If we have `n <= m` then we can conclude that `n <= S m` is valid
as well. These two rules are expressed in Coq with an inductive type.

    Inductive le (n : nat) : nat -> Prop :=
    | le_n : n <= n
    | le_S : forall m : nat, n <= m -> n <= S m.

`le` has the type `nat -> nat -> Prop` and is therefore a relation. Coq
provides a notation to write `n <= m` instead of `le n m`.

With `le_n n` we prove `n <= n`, and with `le_S n m p` where `n` and `m` are
two natural numbers and `p` is a proof of `n <= m` we prove `n <= S m`.

On the other hand if we have a proof of `n <= m` we can pattern match on the
proof. The case `le_n _` implies that `n = m`. The case `le_S _ k p` gives us
a number `k` whose successor is `m` and a proof `p` for `n <= k`. Note that
the variable `n` in the definition of the inductive type `le` is to the left
on the colon, i.e. it is a parameter. Therefore in the pattern match `le_n`
and `le_S` we cannot bind a variable to it, only the wildcard `_` is allowed.

Using the inductive definition we can prove that `0 <= n` is valid for all
natural numbers `n` by a simple induction proof.

    Theorem zero_is_least:
      forall n, 0 <= n.
    Proof
      fix f n: 0 <= n :=
      match n with
      | 0 => le_n 0
      | S k => le_S 0 k (f k)
      end.

The constructor `le_n` is used to prove the base case and the constructor
`le_S` is used to map `0 <= k` to `0 <= S k`.


Next we prove that `S n <= 0` cannot be valid for any value of `n`. I.e. we
have to prove `S n <= 0 -> False` for all values of `n`.

In order to prove this fact we first prove the lemma `S n <= m -> m <> 0`. We
pattern match on a proof of `S n <= m`. In both case `m` has the form `S k`
and we can use the previous proof `successor_not_zero` to prove that `S k <>
0` is valid. The we feed the lemma with `m` substituted by `0` and get
immediately the desired result.


    Theorem successor_not_below_zero:
      forall n:nat, ~ S n <= 0  (* S n <= 0 -> False *).
    Proof
      let lemma: forall (n m:nat) (p: S n <= m), m <> 0 :=
          fun n m p =>
            match p with
            | le_n _ => @successor_not_zero n: S n <> 0
            | le_S _ k pk => @successor_not_zero k: S k <> 0
            end
      in
      fun n p => lemma n 0 p eq_refl.


Any number less or equal zero must be zero. A simple induction proves this fact.

    Theorem below_zero_is_zero:
      forall n:nat, n <= 0 -> n = 0.
    Proof
      fix f n: n <= 0 -> n = 0 :=
      match n with
      | 0 => fun p => eq_refl
      | S k =>
        (* goal S k <= 0 -> S k = 0 *)
        fun p: S k <= 0 =>
          match successor_not_below_zero p with end
      end.


Now we want to verify that the successor function is monotonic with respect to
`<=` i.e. that `n <= m` implies `S n <= S m`. The prove requires an induction
on the proof of `n <= m`. The second case of the pattern match on a proof of
`n <= m` requires that `m` has the form `S k`. By recursion we get the
induction hypothesis `S n <= S k` and can use the constructor `le_S` to
construct the evidence of `S n <= S (S k)` which is the required result for
that case.

    Theorem successor_monotonic_le:
      forall (n m:nat), n <= m -> S n <= S m.
    Proof
      fix f n m (p:n<=m): S n <= S m :=
      match p with
      | le_n _ => le_n (S n)
      | le_S _ k pk => (* goal: S n <= S (S k) *)
        let hypo: S n <= S k := f n k pk in
        le_S (S n) (S k) hypo
      end.

> Note: This example shows that we can do induction on a proof of `n <= m` and
  not only on the numbers `n` or `m`. This is possible because `<=` has been
  defined inductively. I.e. a proof of `n <= m` is an object of an inductive
  type and we can do recursion on such a proof. The pattern match for the case
  `le_S` can be used to bind a variable (`pk` in the example) to a proof which
  is structurally smaller than the original proof. Therefore the structurally
  smaller variable can be used as an argument of a recursive call to construct
  an induction hypothesis.


The monotonicity holds in the other direction as well. Form `S n <= S m` we
can infer `n <= m`. In order to prove this fact we prove the lemma `n <= m ->
pred n <= pred m`.

    Theorem predecessor_monotonic_le:
      forall n m:nat, n <= m -> pred n <= pred m.
    Proof
      fix f n m p: pred n <= pred m :=
      match p with
      | le_n _ =>
        (* goal: pred n <= pred n *)
        le_n (pred n)
      | le_S _ k pk =>
        (* goal: pred n <= pred (S k),
           proof: Construct a function with type n <= k -> pred n <= pred (S k)
                  and apply it to pk which has type n <= k. The function does a
                  pattern match on k. For k=0, n has to be zero as well. For
                  k = S l use f to generate an induction hypothesis.
         *)
        (match k with
         | O =>
           fun q0:n<=0 =>
             Equal.rewrite
               (Equal.flip (below_zero_is_zero q0: n = 0))
               (fun x => pred x <= pred (S 0))
               (le_n (pred 0))
         | S l =>
           fun ql: n <= S l =>
             let hypo := f n (S l) ql: pred n <= pred (S l) (* ind hypo *)
             in
             le_S (pred n) (pred (S l)) hypo
         end) pk
      end.

> Note: In this proof we pattern match on a proof of `n <= m`. However we need
  a nested pattern match on `k` in order generate a useful induction
  hypothesis. The outer pattern match constructs a proof which is structurally
  smaller than the proof of `n <= m`. The second pattern match gives the
  environment for the recursive call of the proof generating function `f`.

With the lemma the desired proof of `S n <= S m` is trivial.

    Theorem cancel_successor_le:
      forall n m:nat, S n <= S m -> n <= m.
    Proof
      fun n m p =>
        predecessor_monotonic_le p.

This proof works because `pred (S n)` evaluates to `n` for all `n`.


A number `n` is strictly less than a number `m` if the successor of `n` is
less equal `m`. In Coq the function `lt` is defined exactly in this manner.

    Definition lt (n m:nat): Prop := S n <= m.

A notation is provided to be able to write `n < m` instead of `lt n m`.

We proof some easy theorems which relation `<=`, `<` and `=`.

    Theorem lt_implies_le:
      forall (n m:nat), n < m -> n <= m.
    Proof
      fix f n m lt: n <= m :=
      match lt with
      | le_n _ => le_S n n (le_n _)
      | le_S _ k pk => le_S n k (f n k pk)
      end.

    Theorem lt_implies_ne:
      forall (n m:nat), n < m -> n <> m.
    Proof
      fun n m lt eq =>
        let n_lt_n: n < n := Equal.rewrite (Equal.flip eq) _ lt in
        successor_not_le n_lt_n.

    Theorem le_ne_implies_lt:
      forall (n m:nat), n <= m -> n <> m -> S n <= m.
    Proof
      fun n m le =>
        match le with
        | le_n _ => fun n_ne_n => match n_ne_n eq_refl with end
        | le_S _ x p => fun _ => successor_monotonic_le p
        end.
















<!---
Local Variables:
mode: outline
coding: iso-latin-1
outline-regexp: "#+"
End:
-->
