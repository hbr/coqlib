# Existential Quantification

As with the propositional connectives there is no built-in magic for
existential quantification. Existential quantification is defined in the Coq
library as an ordinary inductive type.

    Inductive ex (A: Type) (P:A -> Prop) : Prop :=
      ex_intro: forall (x:A), P x -> ex P.

The term `ex (fun n:nat => n > 0)` is a proposition which states that there
exists a natural number which is greater than zero.

> Note: The first argument `A` of `ex` is implicit and the libraries of Coq
  usually have the statement `Set Arguments Implicit`. This means that
  implicit arguments must not be provided. You can always override this
  locally by prefixing `@` in front of the function and provide all
  arguments. I.e. in the case of existential quantification you can write `@ex
  nat (fun n:nat => n > 0)` which states the same fact as above but is more
  verbose.

The inductive type `ex` has only one constructor `ex_intro` which needs an
object and a proof that the object satisfies the required property.

The Coq library provides a notation shorthand for existential quantification
so that the following two terms are equivalent.

    ex (fun n:nat => n > 0)

    exists n:nat, n > 0

The second form is very intuitive because it has the same form as the
dependent product `forall x:T,e` with `forall` substituted by `exists`. But
you have to realize that the dependent product is built into the language and
the existential quantification is just an inductive definition.

Now we can start to prove propositions with existential quantification. If
there exists an element which satisfies a certain property then it cannot be
the case that all objects do not satisfy this property. This proposition can
be stated in Coq as

    forall (A:Set) (P:A->Prop), (ex P) -> ~ forall x, ~ P x

Before proving this proposition we have to remember that negation has a
definition and that Coq is able to normalize terms and normalization includes
the expansion of definitions. Therefore the tail of the proposition has the
normal form

    (forall x, P x -> False) -> False

In order to prove the proposition we need a function with maps the four
arguments

- `A:Set`: a datatype
- `P:A->Prop`: a property of elements of this datatype
- `p_ex: ex P`:  a proof that there exists some element satisfying the
  property
- `f:forall x, P x -> False` a function which maps all elements `x` and proofs
  of `P x`  into a proof of `False`.

into a proof of `False`.

The proof is very easy. We just have to pull out an element satisfying the
property out of the proof `p_ex` by pattern match and then use the function
`f` to convert the element and its proof that it satisfies the property into a
proof of `False`.

    Goal
      forall (A:Set) (P:A->Prop), (ex P) -> ~ forall x, ~ P x.
    Proof
      fun A P p_ex f =>
        match p_ex with
          ex_intro _ x px => f x px
        end.

It might be instructive to compare this proof by generating directly a proof
term with a proof generated by tactics.

    Goal
      forall (A:Set) (P:A->Prop), (ex P) -> ~ forall x, ~ P x.
    Proof.
      intros A P p_ex f.
      destruct p_ex as [ x p ].
      unfold not in f.
      apply f with (x:=x).
      assumption.
    Qed.




<!---
Local Variables:
mode: outline
coding: iso-latin-1
outline-regexp: "#+"
End:
-->
